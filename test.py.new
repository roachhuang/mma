import time
from ShioajiLogin import shioajiLogin
import shioaji as sj
from shioaji import TickSTKv1, Exchange
from threading import Event
from shioaji.constant import (
    ACTION_BUY,
    ACTION_SELL,
    STOCK_ORDER_LOT_INTRADAY_ODD,
    STOCK_ORDER_LOT_COMMON,
)

api = shioajiLogin(simulation=True)


@api.on_tick_stk_v1()
def quote_callback(exchange: Exchange, tick: TickSTKv1):
    print(f"Exchange: {exchange}, Tick: {tick}")


# api.quote.subscribe(
#     api.Contracts.Stocks["2330"],
#     quote_type=sj.constant.QuoteType.Tick,
#     version=sj.constant.QuoteVersion.v1,
# )


# api.quote.set_on_tick_stk_v1_callback(quote_callback)
# Event().wait()
def place_flexible_order(symbol, price, total_quantity, action):
    # Determine the number of regular lots and odd lot quantity
    regular_lot_qty = total_quantity // 1000  # Regular lots (1 lot = 1000 shares)
    odd_lot_qty = total_quantity % 1000  # Remaining odd lot quantity
    contract = api.Contracts.Stocks[symbol]
    # Place regular lot orders if applicable
    if regular_lot_qty > 0:
        order = api.Order(
            price=price,
            quantity=regular_lot_qty,  # Total quantity in regular lots
            action=action,
            price_type="MKT",
            # price_type="LMT",
            order_type="FOK",
            order_lot=STOCK_ORDER_LOT_COMMON,  # Regular lot
            account=api.stock_account,
        )
        trade = api.place_order(contract, order)
        print(
            f"Placed regular lot order for {symbol}: {regular_lot_qty * 1000} shares @{price}"
        )
        print("status:", trade.status.status)
    # Place odd lot order if applicable
    elif odd_lot_qty > 0:
        order = api.Order(
            price=price,
            quantity=odd_lot_qty,  # Remaining odd lot quantity
            action=action,
            # price_type="LMT",
            price_type="MKT",
            order_type="FOK",
            # order_type="ROD",
            order_lot=STOCK_ORDER_LOT_INTRADAY_ODD,
            account=api.stock_account,
        )
        trade = api.place_order(contract, order)
        print(f"Placed odd lot order for {symbol}: {odd_lot_qty} shares @{price}")
        return order

def get_order_status(order_id):
    """Retrieve the status of an order by its ID."""
    for trade in api.list_trades():
        if trade.order.id == order_id:
            return trade.status.status
    return None  # Return None if the order ID is not found

def wait_for_orders_to_complete(bot, orders):
    """Wait until all orders are either Filled or Failed."""
    while True:
        bot.api.update_status(bot.api.stock_account)
        all_orders_complete = True

        for symbol, order_id in orders.items():
            status = get_order_status(bot, order_id)
            print(f"Symbol: {symbol}, Order ID: {order_id}, Status: {status}")

            if status not in ["Filled", "Failed"]:
                all_orders_complete = False

        if all_orders_complete:
            break

        time.sleep(3)

def process_final_order_status(bot, orders):
    """Process the final statuses of all orders."""
    filled_orders = []
    for symbol, order_id in orders.items():
        status = get_order_status(bot, order_id)
        if status == "Filled":
            print(f"Order for {symbol} has been filled!")
            filled_orders.append(symbol)
        elif status == "Failed":
            print(f"Order for {symbol} failed to fill!")
    return filled_orders

def place_orders(symbols, shares_to_buy, stock_price, action):
    """Place orders for all symbols and return a dictionary of order IDs."""
    orders = {}
    for symbol in symbols:
        trade = place_flexible_order(
            symbol=symbol,
            action=action,
            price=stock_price[symbol],
            total_quantity=int(shares_to_buy[symbol]),
        )
        orders[symbol] = trade.order.id
    return orders


qty = 0
symbol = "2330"


def pos(symbol):
    api.update_status(api.stock_account)
    positions = api.list_positions(api.stock_account, unit="Share")
    # Extract the quantity of the specified stock
    return next(
        (position.quantity for position in positions if position.code == symbol),
        0,  # Default to 0 if the stock is not found
    )


qty = pos(symbol=symbol)
print(f"Stock {symbol} bought quantity: {qty}")
# qty = 10

# Buy stock first to create a position
contract = api.Contracts.Stocks[symbol]  # Example stock
# order = api.Order(
#     price=600,
#     quantity=2,
#     action=sj.constant.Action.Buy,
#     price_type=sj.constant.StockPriceType.MKT,
#     order_type='FOK',
#     account=api.stock_account
# )
# api.place_order(contract, order)
# order
# Sell stock to close the position

order = api.Order(
    price=600,
    quantity=qty / 1000,
    # action=sj.constant.Action.Buy,
    action=sj.constant.Action.Sell,
    price_type=sj.constant.StockPriceType.MKT,
    order_type="FOK",
    order_lot=sj.constant.StockOrderLot.IntradayOdd,
    account=api.stock_account,
)
trade = api.place_order(contract, order)
trade.order.id
# place_flexible_order(symbol=symbol, price=100, total_quantity=qty, action=ACTION_SELL)
cnt = 0
try:
    while True:
        api.update_status(api.stock_account)
        order_status = api.list_trades()[-1].status
        cnt += 1
        print(f"status: {order_status.status}-{cnt}")
        if order_status.status in ["Failed", "Filled", "Cancelled"]:
            # print(f"Order status: {order_status.status}")  # Debug: Current order status
            break
        time.sleep(5)

    if order_status.status == "Filled":
        # todo: write price to file
        print("Order has been filled!")
        # pickle_dump('bought_prices', stockPrice)
    # else:
    # print(f"Order finished with status: {order_status.status}")
    api.logout()


except KeyboardInterrupt:
    print("\n my Ctrl-C detected. Exiting gracefully...")
    # bot.cancelOrders()

    # pickle_dump("money.p", bot1.money)
    try:
        api.logout()
    except Exception as e:
        print("An error occurred:", e)
    finally:
        print(
            "This code is always executed, regardless of whether an exception occurred or not"
        )
    print("end")
    exit
